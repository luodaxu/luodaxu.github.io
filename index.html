<!DOCTYPE html>
<html >
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="罗旭" />


    
    


<meta name="description" content="罗旭的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="罗旭个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="罗旭个人博客">
<meta property="og:description" content="罗旭的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="罗旭个人博客">
<meta name="twitter:description" content="罗旭的博客">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="罗旭个人博客" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>罗旭个人博客</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: undefined
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/me.jpeg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">罗旭</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="/luox199111@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://www.github.com/luodaxu" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 知乎" href="https://www.zhihu.com/people/xu-luo-47" title="知乎"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/">%</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Concurrency/">Concurrency</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fiber-Reconcile/">Fiber Reconcile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/">JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSX/">JSX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scheduling/">Scheduling</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stack-Reconcile/">Stack Reconcile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Virtual-DOM/">Virtual DOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VirtualDom/">VirtualDom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/animation/">animation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/api/">api</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/async/">async</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/">blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cache/">cache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/chrome/">chrome</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/chunkhash/">chunkhash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css3/">css3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/defer/">defer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/etag/">etag</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/extend/">extend</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hash/">hash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html5/">html5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/if-none-match/">if-none-match</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/image/">image</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/include/">include</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lasyman/">lasyman</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/less/">less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lifecycle/">lifecycle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/loader/">loader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mixin/">mixin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/placeholder/">placeholder</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/plugin/">plugin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/property/">property</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/props/">props</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/px-em-rem/">px|em|rem</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sass/">sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stateless/">stateless</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/transform/">transform</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/transition/">transition</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web优化/">web优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/优化/">优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/嵩峰/">嵩峰</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/广丰/">广丰</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/江西/">江西</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/组件化/">组件化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/缓存/">缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高阶组件/">高阶组件</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">后端 SSH2/Shiro, 前端 MKRN</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">罗旭</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/me.jpeg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">罗旭</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/luox199111@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://www.github.com/luodaxu" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 知乎" target="_blank" href="https://www.zhihu.com/people/xu-luo-47" title="知乎"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-webpack优化一" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/26/webpack优化一/" class="article-date">
      <time datetime="2017-12-26T02:43:56.000Z" itemprop="datePublished">2017-12-26</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/26/webpack优化一/">webpack优化一</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="缓存-Caching"><a href="#缓存-Caching" class="headerlink" title="缓存 Caching"></a>缓存 Caching</h1><p>在使用webpack打包模块化应用程序的时候，通常会生成一个可部署的最终的包含虽有目标文件的/dist目录，只要讲此目录的内容部署到服务器上，客户端就能访问网站此服务器的网站及其资源。浏览器使用缓存技术，可以通过命中缓存。以降低网络流量，加快加载速度.<div style="color:red;">但是在部署新版本时不更改资源的文件名，客户端可能认为它没有被更新，就会使用它的缓存版本。由于缓存的存在，当在获取新的代码时，显得棘手。</div></p>
<p>当然webpack肯定也会考虑到适应各种需求的场景，可以通过必要的配置，确保webpack编译声称的文件能背客户端缓存，而在文件内容变化后，能够请求到新的文件。</p>
<h1 id="输出文件的文件名-Output-Filenames"><a href="#输出文件的文件名-Output-Filenames" class="headerlink" title="输出文件的文件名 Output Filenames"></a>输出文件的文件名 Output Filenames</h1><p>webpack配置通过使用 output.filename 进行文件名替换，可以确保浏览器获取到修改后的文。在这里有使用hash和chunkhash相关的概念.详细的区别可以看<a href="http://luodaxu.net/2017/11/16/webpack%E4%B9%8Bhash%E5%92%8Cchunkhash/" target="_blank" rel="external">这里</a>[hash] 替换可以用于在文件名中包含一个构建相关(build-specific)的 hash，但是更好的方式是使用 [chunkhash] 替换，在文件名中包含一个 chunk 相关(chunk-specific)的哈希。<br>下面来个示例：<br>使用html-webpack-plugin管理index.html</p>
<blockquote>
<p>webpack-demo<br> |- package.json<br> |- webpack.config.js<br> |- /dist<br> |- /src<br>&nbsp;&nbsp;|- index.js<br> |- /node-modules</p>
</blockquote>
<p>webpack.config.js</p>
<pre>
  const path = require('path');
  const CleanWebpackPlugin = require('clean-webpack-plugin');
  const HtmlWebpackPlugin = require('html-webpack-plugin');

  module.exports = {
    entry: './src/index.js',
    plugins: [
      new CleanWebpackPlugin(['dist']),
      new HtmlWebpackPlugin({
       title: 'Caching'
      })
    ],
    output: {
        ilename: '[name].[chunkhash].js',
        path: path.resolve(__dirname, 'dist')
    }
  };
</pre>
运行webpack进行打包，控制台打印出如下
>clean-webpack-plugin: /Users/russelluo/luoxu/webpack/webpack_test1/dist has been removed.
Hash: dc6e04f9a083f28e96e3
Version: webpack 2.7.0
Time: 506ms
                       Asset       Size  Chunks             Chunk Names
main.ff4067774e832639fd98.js    2.84 kB       0  [emitted]  main
                  index.html  200 bytes          [emitted]  
   [0] ./src/index.js 209 bytes {0} [built]
Child html-webpack-plugin for "index.html":
       [0] ./~/lodash/lodash.js 540 kB {0} [built]
       [1] ./~/html-webpack-plugin/lib/loader.js!./~/html-webpack-plugin/default_index.ejs 538 bytes {0} [built]
       [2] (webpack)/buildin/global.js 509 bytes {0} [built]
       [3] (webpack)/buildin/module.js 517 bytes {0} [built]

# 提取模版(Extracting Boilerplate)
代码分离是经常来优化性能的一种方法，在webpack中内部自身提供了CommonsChunkPlugin 来用于将模块分离到单独的文件中。<div style="color:red;font-size: 24px;">然而CommonsChunkPlugin还有个很少人知道的功能，能够在每次修改后的构建过程中，将webpack的样板boilerplate和maniest提取出来，只需要通过entry配置中未用到的名称，此插件会自动将我们需要的内容提取到单独的包中。</div>
修改webpack的配置：
<pre>
module.exports = {
    entry: './src/index.js',
    plugins: [
        new CleanWebpackPlugin(['dist']),
        new HtmlWebpackPlugin({
            title: 'Code split'
        }),
        new webpack.optimize.CommonsChunkPlugin({
                name: 'runtime'
        })
    ],
    output: {
        filename: '[name].[chunkhash].js',
        path: path.resolve(__dirname, 'dist')
    }
}
</pre>
控制台此时输出：
>clean-webpack-plugin: /Users/russelluo/luoxu/webpack/webpack_test1/dist has been removed.
Hash: 17df37411378c36d9834
Version: webpack 2.7.0
Time: 440ms
                          Asset       Size  Chunks             Chunk Names
   main.34659e4ea92f7d7608c3.js  290 bytes       0  [emitted]  main
runtime.b31afe01242800586eaa.js    5.98 kB       1  [emitted]  runtime
                     index.html  278 bytes          [emitted]  
   [0] ./src/index.js 209 bytes {0} [built]
Child html-webpack-plugin for "index.html":
       [0] ./~/lodash/lodash.js 540 kB {0} [built]
       [1] ./~/html-webpack-plugin/lib/loader.js!./~/html-webpack-plugin/default_index.ejs 538 bytes {0} [built]
       [2] (webpack)/buildin/global.js 509 bytes {0} [built]
       [3] (webpack)/buildin/module.js 517 bytes {0} [built]

这里多了个runtime的单独的包，下面我们从代码层次上分析下,没有runtime单独代码包下代码：
<pre>
/******/ (function(modules) { // webpackBootstrap
/******/     // The module cache
/******/     var installedModules = {};
/******/
/******/     // The require function
/******/     function __webpack_require__(moduleId) {
/******/
/******/         // Check if module is in cache
/******/         if(installedModules[moduleId]) {
/******/             return installedModules[moduleId].exports;
/******/         }
/******/         // Create a new module (and put it into the cache)
/******/         var module = installedModules[moduleId] = {
/******/             i: moduleId,
/******/             l: false,
/******/             exports: {}
/******/         };
/******/
/******/         // Execute the module function
/******/         modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/         // Flag the module as loaded
/******/         module.l = true;
/******/
/******/         // Return the exports of the module
/******/         return module.exports;
/******/     }
/******/
/******/
/******/     // expose the modules object (__webpack_modules__)
/******/     __webpack_require__.m = modules;
/******/
/******/     // expose the module cache
/******/     __webpack_require__.c = installedModules;
/******/
/******/     // identity function for calling harmony imports with the correct context
/******/     __webpack_require__.i = function(value) { return value; };
/******/
/******/     // define getter function for harmony exports
/******/     __webpack_require__.d = function(exports, name, getter) {
/******/         if(!__webpack_require__.o(exports, name)) {
/******/             Object.defineProperty(exports, name, {
/******/                 configurable: false,
/******/                 enumerable: true,
/******/                 get: getter
/******/             });
/******/         }
/******/     };
/******/
/******/     // getDefaultExport function for compatibility with non-harmony modules
/******/     __webpack_require__.n = function(module) {
/******/         var getter = module && module.__esModule ?
/******/             function getDefault() { return module['default']; } :
/******/             function getModuleExports() { return module; };
/******/         __webpack_require__.d(getter, 'a', getter);
/******/         return getter;
/******/     };
/******/
/******/     // Object.prototype.hasOwnProperty.call
/******/     __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/     // __webpack_public_path__
/******/     __webpack_require__.p = "";
/******/
/******/     // Load entry module and return exports
/******/     return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

function getComponent() {
        var element = document.createElement('div')
        element.innerHTML = _.join(['Hello', 'webpack'], ' ')
        return element;
}

    document.body.appendChild(compnent())


/***/ })
/******/ ]);
</pre>
在使用runtime以后，main.js中只有很简单的
<pre>
webpackJsonp([0],[
/* 0 */
/***/ (function(module, exports) {

function getComponent() {
        var element = document.createElement('div')
        element.innerHTML = _.join(['Hello', 'webpack'], ' ')
        return element;
}

    document.body.appendChild(compnent())


/***/ })
],[0]);
</pre>
在runtime.js中，有一大段不是我们自己编写的代码，这部分可以认为作为webpack自身的一些功能代码。这部分也是可以作为公共代码提取出来的。
<pre>
/******/ (function(modules) { // webpackBootstrap
/******/     // install a JSONP callback for chunk loading
/******/     var parentJsonpFunction = window["webpackJsonp"];
/******/     window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/         // add "moreModules" to the modules object,
/******/         // then flag all "chunkIds" as loaded and fire callback
/******/         var moduleId, chunkId, i = 0, resolves = [], result;
/******/         for(;i < chunkIds.length; i++) {
/******/             chunkId = chunkIds[i];
/******/             if(installedChunks[chunkId]) {
/******/                 resolves.push(installedChunks[chunkId][0]);
/******/             }
/******/             installedChunks[chunkId] = 0;
/******/         }
/******/         for(moduleId in moreModules) {
/******/             if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/                 modules[moduleId] = moreModules[moduleId];
/******/             }
/******/         }
/******/         if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/         while(resolves.length) {
/******/             resolves.shift()();
/******/         }
/******/         if(executeModules) {
/******/             for(i=0; i < executeModules.length; i++) {
/******/                 result = __webpack_require__(__webpack_require__.s = executeModules[i]);
/******/             }
/******/         }
/******/         return result;
/******/     };
/******/
/******/     // The module cache
/******/     var installedModules = {};
/******/
/******/     // objects to store loaded and loading chunks
/******/     var installedChunks = {
/******/         1: 0
/******/     };
/******/
/******/     // The require function
/******/     function __webpack_require__(moduleId) {
/******/
/******/         // Check if module is in cache
/******/         if(installedModules[moduleId]) {
/******/             return installedModules[moduleId].exports;
/******/         }
/******/         // Create a new module (and put it into the cache)
/******/         var module = installedModules[moduleId] = {
/******/             i: moduleId,
/******/             l: false,
/******/             exports: {}
/******/         };
/******/
/******/         // Execute the module function
/******/         modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/         // Flag the module as loaded
/******/         module.l = true;
/******/
/******/         // Return the exports of the module
/******/         return module.exports;
/******/     }
/******/
/******/     // This file contains only the entry chunk.
/******/     // The chunk loading function for additional chunks
/******/     __webpack_require__.e = function requireEnsure(chunkId) {
/******/         var installedChunkData = installedChunks[chunkId];
/******/         if(installedChunkData === 0) {
/******/             return new Promise(function(resolve) { resolve(); });
/******/         }
/******/
/******/         // a Promise means "currently loading".
/******/         if(installedChunkData) {
/******/             return installedChunkData[2];
/******/         }
/******/
/******/         // setup Promise in chunk cache
/******/         var promise = new Promise(function(resolve, reject) {
/******/             installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/         });
/******/         installedChunkData[2] = promise;
/******/
/******/         // start chunk loading
/******/         var head = document.getElementsByTagName('head')[0];
/******/         var script = document.createElement('script');
/******/         script.type = 'text/javascript';
/******/         script.charset = 'utf-8';
/******/         script.async = true;
/******/         script.timeout = 120000;
/******/
/******/         if (__webpack_require__.nc) {
/******/             script.setAttribute("nonce", __webpack_require__.nc);
/******/         }
/******/         script.src = __webpack_require__.p + "" + chunkId + "." + {"0":"34659e4ea92f7d7608c3"}[chunkId] + ".js";
/******/         var timeout = setTimeout(onScriptComplete, 120000);
/******/         script.onerror = script.onload = onScriptComplete;
/******/         function onScriptComplete() {
/******/             // avoid mem leaks in IE.
/******/             script.onerror = script.onload = null;
/******/             clearTimeout(timeout);
/******/             var chunk = installedChunks[chunkId];
/******/             if(chunk !== 0) {
/******/                 if(chunk) {
/******/                     chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));
/******/                 }
/******/                 installedChunks[chunkId] = undefined;
/******/             }
/******/         };
/******/         head.appendChild(script);
/******/
/******/         return promise;
/******/     };
/******/
/******/     // expose the modules object (__webpack_modules__)
/******/     __webpack_require__.m = modules;
/******/
/******/     // expose the module cache
/******/     __webpack_require__.c = installedModules;
/******/
/******/     // identity function for calling harmony imports with the correct context
/******/     __webpack_require__.i = function(value) { return value; };
/******/
/******/     // define getter function for harmony exports
/******/     __webpack_require__.d = function(exports, name, getter) {
/******/         if(!__webpack_require__.o(exports, name)) {
/******/             Object.defineProperty(exports, name, {
/******/                 configurable: false,
/******/                 enumerable: true,
/******/                 get: getter
/******/             });
/******/         }
/******/     };
/******/
/******/     // getDefaultExport function for compatibility with non-harmony modules
/******/     __webpack_require__.n = function(module) {
/******/         var getter = module && module.__esModule ?
/******/             function getDefault() { return module['default']; } :
/******/             function getModuleExports() { return module; };
/******/         __webpack_require__.d(getter, 'a', getter);
/******/         return getter;
/******/     };
/******/
/******/     // Object.prototype.hasOwnProperty.call
/******/     __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/     // __webpack_public_path__
/******/     __webpack_require__.p = "";
/******/
/******/     // on error function for async loading
/******/     __webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/ })
/************************************************************************/
/******/ ([]);
</pre>

<p>将第三方库提取到单独的vendor chunk文件中，它们很少像本地代码那样频繁修改。利用客户端的长效缓存机制，可以通过命中缓存来消除请求，并减少向服务器获取资源，同时还能保证客户端代码和服务器端代码版本一致。<br>修改webpack配置如下：</p>
<p><pre><br>module.exports = {<br>    entry: {<br>        main: ‘./src/index.js’,<br>        vendor: [‘lodash’, ‘jquery’]<br>    },<br>    plugins: [<br>        new CleanWebpackPlugin([‘dist’]),<br>        new HtmlWebpackPlugin({<br>            title: ‘Code split’<br>        }),<br>        new webpack.optimize.CommonsChunkPlugin({<br>            name: ‘vendor’<br>        }),<br>        new webpack.optimize.CommonsChunkPlugin({<br>            name: ‘runtime’<br>        })<br>    ],<br>    output: {<br>        filename: ‘[name].[chunkhash].js’,<br>        path: path.resolve(__dirname, ‘dist’)<br>    }<br>}<br></pre><br>再次运行，控制台输出：</p>
<blockquote>
<p>clean-webpack-plugin: /Users/russelluo/luoxu/webpack/webpack_test1/dist has been removed.<br>Hash: f76da28c17fefcd18bb6<br>Version: webpack 2.7.0<br>Time: 660ms<br>                          Asset       Size  Chunks                    Chunk Names<br> vendor.90ea04d2de7dac0f2cf9.js     541 kB       0  [emitted]  [big]  vendor<br>   main.750a6f7dd4368b454e0e.js  299 bytes       1  [emitted]         main<br>runtime.481fb272c33ce08f83b3.js    6.01 kB       2  [emitted]         runtime<br>                     index.html  355 bytes          [emitted]<br>   [0] ./~/lodash/lodash.js 540 kB {0} [built]<br>   [1] ./src/index.js 209 bytes {1} [built]<br>   [2] (webpack)/buildin/global.js 509 bytes {0} [built]<br>   [3] (webpack)/buildin/module.js 517 bytes {0} [built]<br>   [4] multi lodash 28 bytes {0} [built]<br>Child html-webpack-plugin for “index.html”:<br>       [0] ./~/lodash/lodash.js 540 kB {0} [built]<br>       [1] ./~/html-webpack-plugin/lib/loader.js!./~/html-webpack-plugin/default_index.ejs 538 bytes {0} [built]<br>       [2] (webpack)/buildin/global.js 509 bytes {0} [built]<br>       [3] (webpack)/buildin/module.js 517 bytes {0} [built]</p>
</blockquote>
<p>注意，引入顺序在这里很重要。CommonsChunkPlugin 的 ‘vendor’ 实例，必须在 ‘runtime’ 实例之前引入.</p>
<h1 id="模块标识符-Module-Identifiers"><a href="#模块标识符-Module-Identifiers" class="headerlink" title="模块标识符 Module Identifiers"></a>模块标识符 Module Identifiers</h1><p>修改index.js文件，加入print.js。<br><code><br>var _ = require(‘lodash’);<br>var Print = require(‘./print’)</code></p>
<p>function getComponent() {<br>    var element = document.createElement(‘div’)<br>    element.innerHTML = _.join([‘Hello’, ‘webpack’], ‘ ‘)<br>    element.onclick = Print.bind(null, ‘hello webpack.’);<br>    return element;<br>}</p>
<pre><code>document.body.appendChild(compnent())
</code></pre><p><br>我们所期待的是main bundle.js 的hash值发生变化，但是通过命令行运行发现：<br><code><br>                          Asset       Size  Chunks                    Chunk Names<br> vendor.442fed026a7f43c947ce.js     541 kB       0  [emitted]  [big]  vendor<br>   main.b5887baed02a97842103.js  550 bytes       1  [emitted]         main<br>runtime.bca7023e88d1c0389852.js    6.01 kB       2  [emitted]         runtime<br></code><br>发现所有的chunhash都变了，说好的呢，那就让我们探探究竟。</p>
<p><div style="color:red">每个module.id会基于默认的解析顺序resolve order进行增量，也就是说当解析顺序发生变化，ID也会随之改变</div>，因此：</p>
<ol>
<li>main bundle会随着自身内容的改变，而发生变化。</li>
<li>vendor bundle 会随着自身的 module.id 的修改，而发生变化。</li>
<li>runtime bundle 会因为当前包含一个新模块的引用，而发生变化。</li>
</ol>
<p>关于这个hash值发生改变的问题，可以看<a href="https://zhuanlan.zhihu.com/p/32361759" target="_blank" rel="external">这里详细</a>，在这里第一个和最后一个都是符合预期的，而vendor的hash发生变化是我们要修复的，这个就不应该发生变化。</p>
<h2 id="为什么没有修改vendor的内容，chunk-hash值却发生变化呢"><a href="#为什么没有修改vendor的内容，chunk-hash值却发生变化呢" class="headerlink" title="为什么没有修改vendor的内容，chunk hash值却发生变化呢"></a>为什么没有修改vendor的内容，chunk hash值却发生变化呢</h2><p>在上述中，删除或者新增业务代码中的模块时，vendor.js的hash偶尔会受到影响。webpack作者给出：</p>
<blockquote>
<p>默认情况下，模块的id是这个模块在模块数组中的索引，OccurenceOrderPlugin会将引用次数多的模块放在前面，在每次编译时模块的顺序都是一致的－－如果修改了代码时新增或者删除模块，这将会影响到所有模块的id。这样不能完全保证vendor.js的hash不受到业务代码的影响。</p>
</blockquote>
<h2 id="如何解决因为业务代码造成的hash值变化"><a href="#如何解决因为业务代码造成的hash值变化" class="headerlink" title="如何解决因为业务代码造成的hash值变化"></a>如何解决因为业务代码造成的hash值变化</h2><ol>
<li>NamedModlesPlugin: 使用模块的路径作为hash值的产生，在开发过程中</li>
<li>HashedModuleIdsPlugin: 推荐用语生产环境构建</li>
</ol>
<p>没有使用NamedModlesPlugin：<br><code><br>clean-webpack-plugin: /Users/russelluo/luoxu/webpack/webpack_test1/dist has been removed.<br>Hash: 0bc11dd5c632bc6214ff<br>Version: webpack 2.7.0<br>Time: 626ms<br>                          Asset       Size  Chunks                    Chunk Names<br> vendor.429c0486f009dd34eca6.js     541 kB       0  [emitted]  [big]  vendor<br>   main.a9d4cc5758d2d321b4d4.js  441 bytes       1  [emitted]         main<br>runtime.60cbe870fea38492ab1b.js    6.01 kB       2  [emitted]         runtime<br>                     index.html  355 bytes          [emitted]<br>[Fy2T] (webpack)/buildin/global.js 509 bytes {0} [built]<br>[KJEK] (webpack)/buildin/module.js 517 bytes {0} [built]<br>[M4fF] ./~/lodash/lodash.js 540 kB {0} [built]<br>   [0] multi lodash 28 bytes {0} [built]<br>[lVK7] ./src/index.js 316 bytes {1} [built]<br>Child html-webpack-plugin for “index.html”:<br>    [Fy2T] (webpack)/buildin/global.js 509 bytes {0} [built]<br>    [KJEK] (webpack)/buildin/module.js 517 bytes {0} [built]<br>    [M4fF] ./~/lodash/lodash.js 540 kB {0} [built]<br>    [a/t9] ./~/html-webpack-plugin/lib/loader.js!./~/html-webpack-plugin/default_index.ejs 538 bytes {0} [built]<br></code><br>使用之后NamedModlesPlugin：<br><code><br>clean-webpack-plugin: /Users/russelluo/luoxu/webpack/webpack_test1/dist has been removed.<br>Hash: cde8dfda99787f002bc9<br>Version: webpack 2.7.0<br>Time: 725ms<br>                          Asset       Size  Chunks                    Chunk Names<br> vendor.429c0486f009dd34eca6.js     541 kB       0  [emitted]  [big]  vendor<br>   main.b61ce1aa38f8147c51e6.js  567 bytes       1  [emitted]         main<br>runtime.7f57b8ef1fd6b7d107db.js    6.01 kB       2  [emitted]         runtime<br>                     index.html  355 bytes          [emitted]<br>[3Di9] ./src/print.js 60 bytes {1} [built]<br>[Fy2T] (webpack)/buildin/global.js 509 bytes {0} [built]<br>[KJEK] (webpack)/buildin/module.js 517 bytes {0} [built]<br>[M4fF] ./~/lodash/lodash.js 540 kB {0} [built]<br>   [0] multi lodash 28 bytes {0} [built]<br>[lVK7] ./src/index.js 310 bytes {1} [built]<br>Child html-webpack-plugin for “index.html”:<br>    [Fy2T] (webpack)/buildin/global.js 509 bytes {0} [built]<br>    [KJEK] (webpack)/buildin/module.js 517 bytes {0} [built]<br>    [M4fF] ./~/lodash/lodash.js 540 kB {0} [built]<br>    [a/t9] ./~/html-webpack-plugin/lib/loader.js!./~/html-webpack-plugin/default_index.ejs 538 bytes {0} [built]<br></code><br>这回是好了,本文至此结束。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/">webpack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/优化/">优化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/缓存/">缓存</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-webpack之自定义插件" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/05/webpack之自定义插件/" class="article-date">
      <time datetime="2017-12-05T02:29:08.000Z" itemprop="datePublished">2017-12-05</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/05/webpack之自定义插件/">webpack之自定义插件</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>webpack已经到3版本了，功能强大，使用方便，是构建spa的必备良药，但是总归有时候需要自定义写个webpack插件，那只能去看看官方文档了，瞟了下，发现英文文档看的不是很懂，怎么办，慢慢看，毕竟官方的才是最最权威的，下面将结合自己的理解和他人文档，总结出来的，不喜勿喷，也希望错误的地方能指正出来并改正。</p>
<h1 id="关于-webpack中的compiler和compilation两个概念"><a href="#关于-webpack中的compiler和compilation两个概念" class="headerlink" title="关于 webpack中的compiler和compilation两个概念"></a>关于 webpack中的compiler和compilation两个概念</h1><p>在阅读文档后，发现compiler和compilation这两个术语出现的概率非常高，几乎所有的webpack插件都是通过这两个对象去实现的。下面我们一起先探讨下compiler和compilation两个概念。</p>
<blockquote>
<p>原文：<a href="https://webpack.js.org/development/how-to-write-a-plugin/" target="_blank" rel="external">https://webpack.js.org/development/how-to-write-a-plugin/</a></p>
</blockquote>
<p>1.compiler<br>官方的定义是</p>
<blockquote>
<p>The compiler object represents the fully configured webpack environment. This object is built once upon starting webpack, and is configured with all operational settings including options, loaders, and plugins. When applying a plugin to the webpack environment, the plugin will receive a reference to this compiler. Use the compiler to access the main webpack environment.</p>
</blockquote>
<p>翻译成中文为：</p>
<blockquote>
<p>compiler对象代表webpack环境所有的配置信息，这个对象在webpack启动时被构建，配置信息包含了options，loaders，和plugins。当启动一个插件到webpack环境的时候，这个插件就会接受一个compiler的参数，使用这个参数可以获取webpack的配置信息。<br>这就意味者compiler代表的就是webpack配置环境信息，可以获取到所有webpack配置内容，并且这个参数会被传进各个插件，通过这个compiler对象可以对插件进行控制管理。</p>
</blockquote>
<p>2.compilation<br>官方的定义是：</p>
<blockquote>
<p>A compilation object represents a single build of versioned assets. While running webpack development middleware, a new compilation will be created each time a file change is detected, thus generating a new set of compiled assets. A compilation surfaces information about the present state of module resources, compiled assets, changed files, and watched dependencies. The compilation also provides many callback points at which a plugin may choose to perform custom actions.</p>
</blockquote>
<p>翻译成中文为：</p>
<blockquote>
<p>compilation对象代表一个单一的版本构建的资源，在webpack运行中间件时候，每当一个文件发生改变时就会产生一个新的complation，从而产生一个新的编译后的资源集合。complation列出了很多关于当前模块资源的信息，编译后的资源信息，改动过的文件以及监听国的依赖。compilation也提供了插件需要自定义功能的回调点。</p>
</blockquote>
<p>这两个对象在所有的webpack插件中都是不可分割的一部分，要开发一个优秀的webpack插件必须要熟练这两个对象的意义并熟练使用。这两个对象和hash/chunkhash有密切的联系。</p>
<h1 id="插件的基本结构"><a href="#插件的基本结构" class="headerlink" title="插件的基本结构"></a>插件的基本结构</h1><p>每个组件，插件之类豆油应该有生命周期，在某个时刻，插件的生命周期函数将会被调用，webpack也提供了一些API去让开发者去管理控制。</p>
<pre>
/**
 * webpack插件开发采用'动态原型模式'
 * 插件开发，最重要的两个对象：compiler、compilation
 * @param options
 * @constructor
 */
function MyPlugin(options) { // 根据 options 配置你的插件

}
// 我们可以在原型上添加一些方法
MyPlugin.prototype.someFunc = function() {/*something*/}

// apply方法是必须要有的，因为当我们使用一个插件时（new somePlugins({})），webpack会去寻找插件的apply方法并执行
MyPlugin.prototype.apply = function(compiler) {
  // compiler是什么？compiler是webpack的'编译器'引用


  // compiler.plugin('***')和compilation.plugin('***')代表什么？
  // document.addEventListener熟悉吧？其实是类似的
  // compiler.plugin('***')就相当于给compiler设置了事件监听
  // 所以compiler.plugin('compile')就代表：当编译器监听到compile事件时，我们应该做些什么

  // compile（'编译器'对'开始编译'这个事件的监听）
  compiler.plugin("compile", function(params) {
    console.log("The compiler is starting to compile...");
  });

  // compilation（'编译器'对'编译ing'这个事件的监听）
  compiler.plugin("compilation", function(compilation) {
    console.log("The compiler is starting a new compilation...");
    // 在compilation事件监听中，我们可以访问compilation引用，它是一个代表编译过程的对象引用
    // 我们一定要区分compiler和compilation，一个代表编译器实体，另一个代表编译过程
    // optimize('编译过程'对'优化文件'这个事件的监听)
    compilation.plugin("optimize", function() {
      console.log("The compilation is starting to optimize files...");
    });
  });

  // emit（'编译器'对'生成最终资源'这个事件的监听）
  compiler.plugin("emit", function(compilation, callback) {
    console.log("The compilation is going to emit files...");

    // compilation.chunks是块的集合（构建后将要输出的文件，即编译之后得到的结果）
    compilation.chunks.forEach(function(chunk) {
      // chunk.modules是模块的集合（构建时webpack梳理出的依赖，即import、require的module）
      // 形象一点说：chunk.modules是原材料，下面的chunk.files才是最终的成品
      chunk.modules.forEach(function(module) {
        // module.fileDependencies就是具体的文件，最真实的资源【举例，在css中@import("reset.css")，这里的reset.css就是fileDependencie】
        module.fileDependencies.forEach(function(filepath) {
          // 到这一步，就可以操作源文件了
        });
      });

      // 最终生成的文件的集合
      chunk.files.forEach(function(filename) {
        // source()可以得到每个文件的源码
        var source = compilation.assets[filename].source();
      });
    });

    // callback在最后必须调用
    callback();
  });
};

// 以上compiler和compilation的事件监听只是一小部分，详细API可见该链接http://www.css88.com/doc/webpack2/api/plugins/

module.exports = MyPlugin;
</pre>

<h1 id="一个简单的webpack插件"><a href="#一个简单的webpack插件" class="headerlink" title="一个简单的webpack插件"></a>一个简单的webpack插件</h1><pre>
function FileListPlugin(options) {}

FileListPlugin.prototype.apply = function(compiler) {

    compiler.plugin('compile', function (params) {
       console.log('The compiler is starting to compile...');
    });

    compiler.plugin('emit', function(compilation, callback) {
        // Create a header string for the generated file:
        var filelist = 'In this build:\n\n';

        // Loop through all compiled assets,
        // adding a new line item for each filename.
        for (var filename in compilation.assets) {
            filelist += ('- '+ filename +'\n');
        }

        // Insert this list into the Webpack build as a new file asset:
        compilation.assets['filelist.md'] = {
            source: function() {
                return filelist;
            },
            size: function() {
                return filelist.length;
            }
        };

        callback();
    });
};
</pre>

<p>这是一个简单的webpack plugin，参照<a href="https://webpack.js.org/contribute/writing-a-plugin/#example" target="_blank" rel="external">simple webpack plugin example</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/loader/">loader</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/plugin/">plugin</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/">webpack</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-webpack之hash和chunkhash" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/16/webpack之hash和chunkhash/" class="article-date">
      <time datetime="2017-11-16T06:47:32.000Z" itemprop="datePublished">2017-11-16</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/16/webpack之hash和chunkhash/">webpack之hash和chunkhash</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><div style="display:none;"><a href="http://www.cnblogs.com/ihardcoder/p/5623411.html" target="_blank" rel="external">http://www.cnblogs.com/ihardcoder/p/5623411.html</a></div></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>文件的hash指纹通常是作为前端静态资源实现增量跟新的方案之一，Webpack是目前最流行的开源编译工具之一，我们有必要深入理解其内部的工作方式。</p>
<p>在webpack编译输出的配置过程中，如果要为文件加入hash，webpack提供了两个可配置项：hash和chunkhash.</p>
<h1 id="hash和chunkhash"><a href="#hash和chunkhash" class="headerlink" title="hash和chunkhash"></a>hash和chunkhash</h1><p>首先我们看下官方文档对两者的定义<br>hash: [hash] is replaced by the hash of the compilation，hash代表的是compilation的hash值。<br>chunkhash: [chunkhash] is replaced by the hash of the chunk. chunkhash代表的是chunk的hash值。<br>chunkhash我们可以这么理解，chunk就是模块，chunkhash就是根据模块内容计算出的hash值。那么如何理解hash呢？</p>
<h2 id="compilation"><a href="#compilation" class="headerlink" title="compilation"></a>compilation</h2><p>webpack官方文档中how to write a plugin对 compilation的详解</p>
<blockquote>
<p>A compilation object represents a single build of versioned assets. While running Webpack development middleware, a new compilation will be created each time a file change is detected, thus generating a new set of compiled assets. A compilation surfaces information about the present state of module resources, compiled assets, changed files, and watched dependencies.<br>compilation对象代表某个版本的资源对应的编译进程。当使用Webpack的development中间件时，每次检测到项目文件有改动就会创建一个compilation，进而能够针对改动生产全新的编译文件。compilation对象包含当前模块资源、待编译文件、有改动的文件和监听依赖的所有信息。</p>
</blockquote>
<p>与compilation对应的有个compiler对象，通过对比，可以帮助大家对compilation有更深入的理解。</p>
<blockquote>
<p>The compiler object represents the fully configured Webpack environment. This object is built once upon starting Webpack, and is configured with all operational settings including options, loaders, and plugins.</p>
</blockquote>
<p>compiler对象代表的是配置完备的Webpack环境。 compiler对象只在Webpack启动时构建一次，由Webpack组合所有的配置项构建生成。</p>
<p>简单的讲，compiler对象代表的是不变的webpack环境，是针对webpack的；而compilation对象针对的是随时可变的项目文件，只要文件有改动，compilation就会被重新创建。</p>
<p>compilation在项目中任何一个文件改动后就会被重新创建，然后webpack计算新的compilation的hash值，这个hash值便是hash</p>
<p>如果使用hash作为编译文件的hash指纹的话，如下</p>
<p><pre>output: {<br>        filename: ‘[name].[hash:8],js’,<br>        path: __dirname + ‘/build’<br>    }<br></pre><br>hash是compilation对象计算所得，而不是具体的项目文件计算所得。所以以上配置的编译输出文件，所有的文件名都会使用相同的hash指纹。如下：<br> <img src="/img/hash.png" alt="/img/hash.png"></p>
<p>当然这样还是存在问题的。三个js文件</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/chunkhash/">chunkhash</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hash/">hash</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/">webpack</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Web优化之Web缓存知识" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/16/Web优化之Web缓存知识/" class="article-date">
      <time datetime="2017-11-16T03:49:24.000Z" itemprop="datePublished">2017-11-16</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/16/Web优化之Web缓存知识/">Web优化之Web缓存知识</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Web缓存指的是可以自动保存常见http请求副本的http设备，对于前端开发者来说，我们通常打交道的是浏览器。除此之外，各种各样的代理服务器也可以做缓存，相当于一个中间者的作用。当web请求到达缓存时，缓存从本地副本中提取这个副本内容而不需要经过服务器，带来以下优点：</p>
<ol>
<li>缓存减少了冗余的数据传输，节省流量。</li>
<li>缓存缓解了带宽瓶颈问题。不需要更多的带宽就能更快加载页面</li>
<li>缓存缓解了瞬间拥塞，降低了对原始服务器的要求。</li>
<li>缓存降低了距离延时， 因为从较远的地方加载页面会更慢一些。</li>
</ol>
<p>＃ 缓存的分类<br>缓存可以是单个用户专用的，也可以是多个用户共享的，专用缓存被称为私有缓存，</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cache/">cache</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/etag/">etag</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/if-none-match/">if-none-match</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-React-Fiber-初探" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/14/React-Fiber-初探/" class="article-date">
      <time datetime="2017-11-14T06:55:14.000Z" itemprop="datePublished">2017-11-14</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/14/React-Fiber-初探/">React Fiber 初探</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><div style="color:red;font-size: 28px;">本文将持续更新…..</div></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>React Fiber 是对 React 核心算法的重写，引入了多线程调和特性。React 的产生众所周知，是为了解决 DOM结构复杂或者频繁操作而产生性能瓶颈而出现的技术，重要的一点是引入了Virtual DOM 新概念，实际上 Virtual DOM 是一个 JavaScript 对象。每次，我们只需要告诉 React 下一个状态是什么，React会自己构建一个新的 Virtual DOM，然后根据新旧 Virtual DOM 快速计算其差异，找出需要重绘或重排的元素，告诉浏览器。浏览器根据相关的更新，重新计算 DOM Tree，重绘页面。<br>那么现在的 diff 操作会出现什么问题呢？这样的调度（reconcile）有什么缺点？</p>
<h1 id="新问题"><a href="#新问题" class="headerlink" title="新问题"></a>新问题</h1><p>可以确定的是复杂度为常数的 diff 算法还是很优秀的，但是react 的调度策略 － stack reconcile，这个策略像函数调用栈一样，会深度优先遍历所有的 Virtual DOM 节点，进行Diff。它一定要等整棵 Virtual DOM 计算完成之后，才将任务出栈释放主线程。所以，在浏览器主线程被 React更新状态任务占据的时候，用户与浏览器进行任何的交互都不能得到反馈，只有等到任务结束，才能突然得到浏览器的响应。</p>
<ol>
<li>在 UI 中，不是所有的状态转移都需要立即执行。大量的同时计算可能会导致资源的浪费，以致出现掉帧的状况，降低用户体验。</li>
<li>不同类型的状态转移应有不同的优先级，比如点击按钮出现动画的优先级应该比 Fetch API 要高。</li>
<li>React 是 pull-based 实现的，事务的时序全部由 React 决定。我们没办法操控执行事务的时序。</li>
</ol>
<h1 id="新技术"><a href="#新技术" class="headerlink" title="新技术"></a>新技术</h1><p>现在我们考虑能不能将 react更新状态的任务分为多个事务单元，为每个事务单元设置优先级，并且这些单元有可取消，可重启，可复用等作用。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Concurrency/">Concurrency</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fiber-Reconcile/">Fiber Reconcile</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scheduling/">Scheduling</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Stack-Reconcile/">Stack Reconcile</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-css3-transform-transition-animation-续2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/25/css3-transform-transition-animation-续2/" class="article-date">
      <time datetime="2017-01-25T07:37:37.000Z" itemprop="datePublished">2017-01-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/25/css3-transform-transition-animation-续2/">css3-transform-transition-animation-续2</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h2><p>Animation之前我们有必要先来了解一个特殊的东西，那就是”Keyframes”,我们把他叫做“关键帧”,Keyframes具有其自己的语法规则，他的命名是由”@keyframes”开头，后面紧接着是这个“动画的名称”加上一对花括号“{}”，括号中就是一些不同时间段样式规则，有点像我们css的样式写法一样。对于一个”@keyframes”中的样式规则是由多个百分比构成的，如“0%”到”100%”之间，我们可以在这个规则中创建多个百分比，我们分别给每一个百分比中给需要有动画效果的元素加上不同的属性，从而让元素达到一种在不断变化的效果，比如说移动，改变元素颜色，位置，大小，形状等，不过有一点需要注意的是，我们可以使用“fromt”“to”来代表一个动画是从哪开始，到哪结束，也就是说这个 “from”就相当于”0%”而”to”相当于”100%”,值得一说的是，其中”0%”不能像别的属性取值一样把百分比符号省略，我们在这里必须加上百分符号（“%”）如果没有加上的话，我们这个keyframes是无效的，不起任何作用。因为keyframes的单位只接受百分比值。</p>
<h4 id="animation属性"><a href="#animation属性" class="headerlink" title="animation属性"></a>animation属性</h4><ol>
<li>animation-name<blockquote>
<p>animation-name: none | IDENT[,none | IDENT]</p>
</blockquote>
</li>
</ol>
<p>animation-name:是用来定义一个动画的名称，其主要有两个值：IDENT是由Keyframes创建的动画名，换句话说此处的IDENT要和Keyframes中的IDENT一致，如果不一致,将不能实现任何动画效果；none为默认值，当值为none时，将没有任何动画效果。另外我们这个属性跟前面所讲的transition一样，我们可以同时附几个animation给一个元素，我们只需要用逗号“，”隔开。</p>
<ol>
<li>animation-duration<blockquote>
<p> animation-duration: <time>[,<time>]*</time></time></p>
</blockquote>
</li>
</ol>
<p>animation-duration是用来指定元素播放动画所持续的时间长，取值:<time>为数值，单位为s （秒.）其默认值为“0”。这个属性跟transition中的transition-duration使用方法是一样的。</time></p>
<ol>
<li>animation-timing-function<blockquote>
<p>  animation-timing-function:ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>) [, ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)]*</number></number></number></number></number></number></number></number></p>
</blockquote>
</li>
</ol>
<p>animation-timing-function:是指元素根据时间的推进来改变属性值的变换速率，说得简单点就是动画的播放方式。他和transition中的transition-timing-function一样，具有以下六种变换方式：ease;ease-in;ease-in-out;linear;cubic-bezier。具体的使用方法大家可以点这里，查看其中transition-timing-function的使用方法。</p>
<ol>
<li>animation-delay<blockquote>
<p> animation-delay: <time>[,<time>]*</time></time></p>
</blockquote>
</li>
</ol>
<p>animation-delay:是用来指定元素动画开始时间。取值为<time>为数值，单位为s(秒)，其默认值也是0。这个属性和transition-delayy使用方法是一样的。</time></p>
<ol>
<li>animation-direction<blockquote>
<p> animation-direction: normal | alternate [, normal | alternate]</p>
</blockquote>
</li>
</ol>
<p>animation-direction是用来指定元素动画播放的方向，其只有两个值，默认值为normal，如果设置为normal时，动画的每次循环都是向前播放；另一个值是alternate，他的作用是，动画播放在第偶数次向前播放，第奇数次向反方向播放。</p>
<ol>
<li>animation-direction<blockquote>
<p> animation-direction: normal | alternate [, normal | alternate]</p>
</blockquote>
</li>
</ol>
<p>animation-direction是用来指定元素动画播放的方向，其只有两个值，默认值为normal，如果设置为normal时，动画的每次循环都是向前播放；另一个值是alternate，他的作用是，动画播放在第偶数次向前播放，第奇数次向反方向播放。</p>
<ol>
<li>animation-play-state<blockquote>
<p>  animation-play-state:running | paused [, running | paused]</p>
</blockquote>
</li>
</ol>
<p>animation-play-state主要是用来控制元素动画的播放状态。其主要有两个值，running和paused其中running为默认值。他们的作用就类似于我们的音乐播放器一样，可以通过paused将正在播放的动画停下了，也可以通过running将暂停的动画重新播放，我们这里的重新播放不一定是从元素动画的开始播放，而是从你暂停的那个位置开始播放。另外如果暂时了动画的播放，元素的样式将回到最原始设置状态。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-css3-transform-transition-animation-续1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/25/css3-transform-transition-animation-续1/" class="article-date">
      <time datetime="2017-01-25T06:34:39.000Z" itemprop="datePublished">2017-01-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/25/css3-transform-transition-animation-续1/">css3-transform-transition-animation(续1)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><p>定义：css的transition允许css的属性值在一定的时间区间内平滑地过度，这种效果可以在鼠标单击、获得焦点、被点击或对元素任何改变中触发，并圆滑地以动画效果改变CSS的属性值。<br>属性值:</p>
<blockquote>
<p> transition ： [&lt;’transition-property’&gt; || &lt;’transition-duration’&gt; || &lt;’transition-timing-function’&gt; ||<br>    &lt;’transition-delay’&gt; [, [&lt;’transition-property’&gt; || &lt;’transition-duration’&gt; ||<br>    &lt;’transition-timing-function’&gt; || &lt;’transition-delay’&gt;]]*</p>
</blockquote>
<h4 id="transition-property"><a href="#transition-property" class="headerlink" title="transition-property"></a>transition-property</h4><p>transition-property是用来指定当元素其中一个属性改变时执行transition效果，取值为:<br>all: 所有属性，默认值<br>indent: 元素属性名<br>none：transition马上停止执行</p>
<h4 id="transition-duration"><a href="#transition-duration" class="headerlink" title="transition-duration"></a>transition-duration</h4><p>transition-duration是用来指定元素 转换过程的持续时间，取值：<time>为数值，单位为s（秒）或者ms(毫秒),可以作用于所有元素，包括:before和:after伪元素。其默认值是0，也就是变换时是即时的。</time></p>
<h4 id="transition-timing-function"><a href="#transition-timing-function" class="headerlink" title="transition-timing-function"></a>transition-timing-function</h4><blockquote>
<p> transition-timing-function ： ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>) [, ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)]*</number></number></number></number></number></number></number></number></p>
</blockquote>
<p>transition-timing-function的值允许你根据时间的推进去改变属性值的变换速率，transition-timing-function有6个可能值：<br>1、ease：（逐渐变慢）默认值，ease函数等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0).<br>2、linear：（匀速），linear 函数等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0).<br>3、ease-in：(加速)，ease-in 函数等同于贝塞尔曲线(0.42, 0, 1.0, 1.0).<br>4、ease-out：（减速），ease-out 函数等同于贝塞尔曲线(0, 0, 0.58, 1.0).<br>5、ease-in-out：（加速然后减速），ease-in-out 函数等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)<br>6、cubic-bezier：（该值允许你去自定义一个时间曲线）， 特定的cubic-bezier曲线。 (x1, y1, x2, y2)四个值特定于曲线上点P1和点P2。所有值需在[0, 1]区域内，否则无效。<br>其是cubic-bezier为通过贝赛尔曲线来计算“转换”过程中的属性值，如下曲线所示，通过改变P1(x1, y1)和P2(x2, y2)的坐标可以改变整个过程的Output Percentage。初始默认值为default.</p>
<h4 id="transition-delay"><a href="#transition-delay" class="headerlink" title="transition-delay"></a>transition-delay</h4><p>transition-delay是用来指定一个动画开始执行的时间，也就是说当改变元素属性值后多长时间开始执行transition效果，其取值：<time>为数值，单位为s（秒）或者ms(毫秒)，其使用和transition-duration极其相似，也可以作用于所有元素，包括:before和:after伪元素。 默认大小是”0”，也就是变换立即执行，没有延迟。</time></p>
<p>有时我们不只改变一个css效果的属性,而是想改变两个或者多个css属性的transition效果，那么我们只要把几个transition的声明串在一起，用逗号（“，”）隔开，然后各自可以有各自不同的延续时间和其时间的速率变换方式。但需要值得注意的一点：transition-delay与transition-duration的值都是时间，所以要区分它们在连写中的位置，一般浏览器会根据先后顺序决定，第一个可以解析为时间的怭值为transition-duration第二个为transition-delay。如：</p>
<blockquote>
<p>a {<br>    -moz-transition: background 0.5s ease-in,color 0.3s ease-out;<br>    -webkit-transition: background 0.5s ease-in,color 0.3s ease-out;<br>    -o-transition: background 0.5s ease-in,color 0.3s ease-out;<br>    transition: background 0.5s ease-in,color 0.3s ease-out;<br>  }</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/animation/">animation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css3/">css3</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/transform/">transform</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/transition/">transition</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-css3-transform-transition-amination" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/24/css3-transform-transition-amination/" class="article-date">
      <time datetime="2017-01-24T06:26:05.000Z" itemprop="datePublished">2017-01-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/24/css3-transform-transition-amination/">css3-transform,transition,animation</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>CSS3提供了3动画的属性，分别是 transform, transition和animation，下面分别讲解这3个属性。</p>
<h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p>transform的3D在这里暂时不做讲解，读者如果自己有兴趣可以参考官网的讲解。</p>
<h4 id="transform方法"><a href="#transform方法" class="headerlink" title="transform方法"></a>transform方法</h4><table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">translate()</td>
<td style="text-align:left">变动，位移</td>
</tr>
<tr>
<td style="text-align:left">rotate()</td>
<td style="text-align:left">旋转</td>
</tr>
<tr>
<td style="text-align:left">scale()</td>
<td style="text-align:left">比例</td>
</tr>
<tr>
<td style="text-align:left">skew()</td>
<td style="text-align:left">斜拉</td>
</tr>
<tr>
<td style="text-align:left">matrix()</td>
<td style="text-align:left">综合</td>
</tr>
</tbody>
</table>
<p>详细转换方法<br><img src="/img/transform/transform.png" alt=""><br>上述的translate, rotate, scale, skew方法不做详细讲解，使用也比较简单，支持百分比。下面主要讲解下matrix。</p>
<h4 id="matrix函数"><a href="#matrix函数" class="headerlink" title="matrix函数"></a>matrix函数</h4><p>matrix函数可以实现上面的translate, rotate, scale, skew的函数，也就是说matrix函数提供了上述的全部功能。<br><img src="/img/transform/matrix-skew-scale-rotate-translate.gif" alt=""><br>理解transform中matrix()矩阵方法有利于透彻理解CSS3的transform属性，下面将将详细讲解。</p>
<h5 id="transform-与坐标系统"><a href="#transform-与坐标系统" class="headerlink" title="transform 与坐标系统"></a>transform 与坐标系统</h5><p>使用过transform属性旋转的知道，默认是绕着中心点旋转的，这个中心点可以通过 transform-origin 属性控制，后面将会讲解。坐标系统如下图所示。<br><img src="/img/transform/matrix-1.png" alt=""></p>
<h4 id="transform-参数"><a href="#transform-参数" class="headerlink" title="transform 参数"></a>transform 参数</h4><p>matrix支持六个参数，我们分别标记为a, b, c, d, e, f</p>
<blockquote>
<p>transform: matrix(a, b, c, d, e, f);</p>
</blockquote>
<p><img src="/img/transform/matrix-2.gif" alt=""><br>注意书写是竖着的，经过这个矩阵变换成<br><img src="/img/transform/matrix-3.gif" alt=""><br>其中 x, y 代表转化元素的坐标变量，那么<strong>ax+cy+e</strong>的意义又是什么？ 其实<strong>ax+cy+e</strong>为变换后的水平坐标<strong>bx+dy+f</strong>为变换后的垂直位置。举个例子</p>
<blockquote>
<p>transform(1, 0, 0, 1, 30, 30); // a=1, b=0, c=0, d=1, e=30, f=30</p>
</blockquote>
<p>现在假设中心点坐标为(0, 0)，即x=0, y=0，那么x坐标变化后就是ax+by+e = 1<em>0+0</em>0+30 = 30, y坐标就是bx+dy+f = 30；于是坐标从(0, 0) -&gt; (30, 30)，实际上transform: matrix(1, 0, 0, 1, 30, 30);就等同于transform: translate(30px, 30px);. 注意：translate, rotate等方法都是需要单位的，而matrix方法e, f参数的单位可以省略。<br>于是第一步总结为:</p>
<blockquote>
<p>transform: matrix(a, b, c, d, 水平偏移距离, 垂直偏移距离)</p>
</blockquote>
<h4 id="matrix矩阵与缩放，旋转以及拉伸"><a href="#matrix矩阵与缩放，旋转以及拉伸" class="headerlink" title="matrix矩阵与缩放，旋转以及拉伸"></a>matrix矩阵与缩放，旋转以及拉伸</h4><p>偏移很好理解，下面进一步讲解matrix矩阵的缩放，旋转和拉伸效果。</p>
<ul>
<li>缩放 scale<br>我们知道公式，克推导：<blockquote>
<p>x’ = ax + by + e = ax + 0<em>y+0 = ax // x放大倍数<br>y’ = cx + dy + f= 0</em>x +d*y + f = dy // y放大倍数</p>
</blockquote>
</li>
</ul>
<p>总结公式为: <strong>transform: matrix(a, 0, 0, d, 0, 0)</strong><br>也就是matrix(sx, 0, 0, sy, 0, 0);，等同于scale(sx, sy);</p>
<ul>
<li>旋转 rotate<br>旋转相对麻烦，涉及到了角度问题，假设旋转的角度θ，我们取特殊值去求解。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">x&apos; = ax + by 表达式1</div><div class="line">y&apos; = cx + dy 表达式2</div><div class="line"></div><div class="line">取原坐标(x, 0)，则上面表达式1为x&apos;=ax, y&apos;=cx，下面旋转θ后，x&apos;=cosθx, y&apos;=-sinθx，则</div><div class="line">x&apos; = ax = cosθx</div><div class="line">y&apos; = cx = -sinθx</div><div class="line">推导出a = cosθ, c = -sinθ</div><div class="line">同理推出b = sinθ, d = cosθ</div></pre></td></tr></table></figure>
</li>
</ul>
<p>总结：旋转公式为<strong>transform: matrix(cosθ, sinθ, -sinθ, cosθ, 0, 0)</strong><br>但是还是推荐使用rotate函数，简介明了，毕竟要去计算。</p>
<ul>
<li>斜拉 skew<br>总结：旋转公式为<strong>transform: matrix(1, tan(θy),tan(θx), 1, 0, 0)</strong></li>
</ul>
<h4 id="如何根据实际需求使用matrix"><a href="#如何根据实际需求使用matrix" class="headerlink" title="如何根据实际需求使用matrix"></a>如何根据实际需求使用matrix</h4><p>当想使用matrix的时候无非上述四个需求不能同时满足，而使用matrix最大的难点就是计算matrix函数的参数值，下面我们通过举个例子介绍下如何计算。<br>需求：图像以 y=x 轴进行旋转<br><img src="/img/transform/matrix-4.png" alt=""><br>那如何计算参数值呢？<br>其实很简单，无非就是先在图形上假设一个坐标点(x, y)，经过变化后的坐标值为 (x’, y’)，计算出这两个的关系式不就能算出来了嘛<br>A: 小学数学，(x’, y’)和(x, y)的连线与y=kx垂直，则，</p>
<blockquote>
<p>(y’-y)/(x’-x) = -1/k  -&gt; ky’-ky = x’-x</p>
</blockquote>
<p>B: 小学数学，(x’, y’)和(x, y)的中点在y=kx上面，则，</p>
<blockquote>
<p>(y’+y)/2 = k * (x’+x)/2 -&gt; kx+kx’ = y+y’</p>
</blockquote>
<p>下面解方程，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x&apos; = (1-k*k)/(k*k+1) *x + 2k/(k*k+1) *y;</div><div class="line">y&apos; = 2k/(k*k+1) *x + (k*k-1)/(k*k+1) *y;</div><div class="line">结合矩阵：</div><div class="line">x&apos; = ax+cy+e;</div><div class="line">y&apos; = bx+dy+f;</div></pre></td></tr></table></figure></p>
<p>最终得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = (1-k*k)/(k*k+1);</div><div class="line">b = 2k/(k*k+1);</div><div class="line">c = 2k/(k*k+1);</div><div class="line">d = (k*k-1)/(k*k+1);</div></pre></td></tr></table></figure></p>
<p>所以说 transform matrix也不过如此.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/animation/">animation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css3/">css3</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/transform/">transform</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/transition/">transition</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-react-高阶组件" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/23/react-高阶组件/" class="article-date">
      <time datetime="2017-01-23T06:04:59.000Z" itemprop="datePublished">2017-01-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/23/react-高阶组件/">react-高阶组件</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>目前的前端社区，推荐组件化，组件化又推荐组合而非继承，组合是业务和视图的组合，这样最小粒化组件，又不失去灵活性和可控性。mixin也是一种比较好的实践，但是自身自身的一些问题而慢慢不被推崇。高阶组件(Higher Order Comopnent, HOC)作为mixin之外的一种组件抽象与处理形式，自身有许多好处。高阶组件是一个非常棒的形式，它已经在多个 React 库中被证明了它的价值，本文将深入学习分析。<br>读者最好有React/ES6等基础知识。</p>
<h4 id="什么是高阶组件"><a href="#什么是高阶组件" class="headerlink" title="什么是高阶组件"></a>什么是高阶组件</h4><blockquote>
<p>一个高阶组件只是一个包装了另外一个React组件的React组件</p>
</blockquote>
<p>熟悉函数式编程的读者知道这可以被描述成一个函数，本质上是一个类工程(class factory)，这是我们再熟悉不过的一种设计模式。下方的函数标签伪代码启发来自Haskell，一种推荐函数式的编程语言。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hocFactory:: W: React.Comopnent =&gt; E: React.Comopnent</div></pre></td></tr></table></figure></p>
<p>这里的W是 WrappedComponent缩写，指被包装的React.Comopnent，E是EnhancedCompnent的缩写，指的是包装最后返回的新的高阶React组件。<br>在这里中的<strong>包装</strong>指的是两件事，也就是两个功能。</p>
<ol>
<li>属性代理（Props Proxy）: 高阶组件操控传递给WrappedComponent的props</li>
<li>反向继承（Inheritance Inversion）: 高阶组件继承（extends）WrappedComponent</li>
</ol>
<p>其实功能1就是 WrappedComponent将由通过EnhancedCompnent获取传递过来的props，例如是某些业务逻辑之类的。功能2就是最终返回的EnhancedCompnent通过这种方式继承(extends)了WrappedComponent的属性。</p>
<h4 id="使用高阶组件做什么"><a href="#使用高阶组件做什么" class="headerlink" title="使用高阶组件做什么"></a>使用高阶组件做什么</h4><p>通过实践后高度概括，高阶组件可以实现下面功能：</p>
<ul>
<li>代码复用，逻辑抽象，抽离底层准备代码(bootstrap)代码</li>
<li>渲染劫持</li>
<li>State抽象和更改</li>
<li>Props更改</li>
</ul>
<p>这些功能是高度概括的，下面通过学习一个高阶组件，学习 <strong>允许/限制</strong> 通过高阶组件我们可以实现哪些功能，如何做到代码的clean。</p>
<h4 id="高阶组件工厂的实现"><a href="#高阶组件工厂的实现" class="headerlink" title="高阶组件工厂的实现"></a>高阶组件工厂的实现</h4><p>在这节中我们将学习两种主流的在 React 中实现高阶组件的方法：属性代理（Props Proxy）和 反向继承（Inheritance Inversion）。两种方法囊括了几种包装 WrappedComponent 的方法。</p>
<h5 id="Props-Proxy-PP-属性代理"><a href="#Props-Proxy-PP-属性代理" class="headerlink" title="Props Proxy (PP) 属性代理"></a>Props Proxy (PP) 属性代理</h5><p>Props Proxy (PP) 属性代理可以理解为EnhancedCompnent替WrappedComponent接收传递过来的组件，最后的实际作用还是在WrappedComponent上，就相当于实现了一个代理一样。举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function ppHOC(WrappedComponent) &#123;</div><div class="line">    return class PP extends React.Component &#123;</div><div class="line">        render() &#123;</div><div class="line">            return &lt;WrappedComponent &#123;...this.props&#125; /&gt;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到这里高阶组件的render方法返回了一个type为WrappedComponent的React Element，高阶组件接收到的props传递给它，因此得名 Props Proxy.</p>
<h5 id="Props-Proxy功能"><a href="#Props-Proxy功能" class="headerlink" title="Props Proxy功能"></a>Props Proxy功能</h5><ol>
<li>更改props</li>
<li>通过refs获取组件实例</li>
<li>抽象state</li>
<li>把 WrappedComponent 与其它 elements 包装在一起</li>
</ol>
<p>（1）更改props<br>这个wrap的过程中我们可以对props进行<strong>读取/增加/修改/删除</strong>等操作将要递给WrappedComponent的props。<br>在修改或删除重要 props 的时候要小心，你可能应该给高阶组件的 props 指定命名空间（namespace），以防破坏从外传递给 WrappedComponent 的 props。<br>例如，添加新的props，这个应用目前登陆的一个用户可以在 WrappedComponent 通过 this.props.user 获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function ppHOC(WrappedComponent) &#123;</div><div class="line">    return class PP extends React.Comopnent &#123;</div><div class="line">        render() &#123;</div><div class="line">            const newProps = &#123;  // 提供新的对象防止修改外部传递的props</div><div class="line">                user: currentLoggedInUser</div><div class="line">            &#125;;</div><div class="line">            return &lt;WrappedComponent &#123;..this.props&#125; &#123;...newProps&#125; /&gt;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>（2）通过refs获取组件实例(Props Proxy with ref demonstration)<br>通过ref获取关键字 <strong>this</strong> (WrappedComponent的实例)，但是必须经历一次正常的渲染过程让ref得到计算，意味着可以在高阶组件的render方法中返回WrappedComponent,让React进行reconciliation过程这之后可以通过ref获取到这个WrappedComponent的实例。<br>例如下面例子就是通过ref获取WrappedComponent实例并调用实例方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function refsHOC(WrappedComponent) &#123;</div><div class="line">    return class refsHOC extends React.Component &#123;</div><div class="line"></div><div class="line">        render() &#123;</div><div class="line">            const props = Object.assign(&#123;&#125;, this.props. &#123;ref: this.proc.bind(this)&#125;);</div><div class="line">            return &lt;WrappedComponent &#123;...props&#125;/&gt;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当 WrappedComponent 被渲染后，ref 上的回调函数 proc 将会执行，此时就有了这个 WrappedComponent 的实例的引用。这个可以用来『读取，添加』实例的 props 或用来执行实例方法。<br>（3）抽象state<br>可以通过向WrappedComponent传递props和callbacks来抽象state。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">function ppHOC(WrappedComponent) &#123;</div><div class="line">    return class PP extends React.Component &#123;</div><div class="line">        constructor(props) &#123;</div><div class="line">            super(props);</div><div class="line">            this.state = &#123;</div><div class="line">                name: &apos;&apos;</div><div class="line">            &#125;;</div><div class="line">            this.onNameChange = this.onNameChange.bind(this);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        onNameChange(e) &#123;</div><div class="line">            this.setState(&#123;</div><div class="line">                name: e.target.value</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        render() &#123;</div><div class="line">            const newProps = &#123;</div><div class="line">                name: &#123;</div><div class="line">                    value: this.state.name,</div><div class="line">                    onChange: this.onNameChange</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125;/&gt;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@ppHOC</div><div class="line">class Example extends React.Comopnent &#123;</div><div class="line">    render() &#123;</div><div class="line">        return &lt;input name=&quot;name&quot; &#123;...this.props.name&#125;/&gt;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时的input是一个可控的input。<br>（4）把WrappedComponent与其他elements包装在一起<br>出于操作样式、布局或其它目的，你可以将 WrappedComponent 与其它组件包装在一起。一些基本的用法也可以使用正常的父组件来实现（附录 B），但是就像之前所描述的，使用高阶组件你可以获得更多的灵活性。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function ppHOC(WrappedComponent) &#123;</div><div class="line">    return class PP extends React.Component &#123;</div><div class="line">        return (</div><div class="line">            &lt;div style=&#123;&#123;display: &apos;block&apos;&#125;&#125;&gt;</div><div class="line">                &lt;WrappedComponent &#123;this.props&#125; /&gt;</div><div class="line">            /div&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="反向继承-Inheritance-Inversion"><a href="#反向继承-Inheritance-Inversion" class="headerlink" title="反向继承(Inheritance Inversion)"></a>反向继承(Inheritance Inversion)</h4><p>反向继承一个简单的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function iiHOC(WrappedComponent) &#123;</div><div class="line">    return class Enhancer extends WrappedComponent &#123;</div><div class="line">        render() &#123;</div><div class="line">            return super.render();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>返回的高阶组件类（Enhancer）继承了WrappedComponent，之所以称之为反向继承是因为WrappedComponent被动地被Enhancer继承，而不是 WrappedComponent 去继承 Enhancer。通过这种方式他们之间的关系倒转了。<br>反向继承允许高阶组件通过 this 关键词获取 WrappedComponent，意味着它可以获取到 state，props，组件生命周期（component lifecycle）钩子，以及渲染方法（render）。<br>是请注意，你可以通过高阶组件来给 WrappedComponent 创建新的生命周期挂钩方法，别忘了调用 super.[lifecycleHook] 防止破坏 WrappedComponent。</p>
<h5 id="React-Reconciliation-过程"><a href="#React-Reconciliation-过程" class="headerlink" title="React Reconciliation 过程"></a>React Reconciliation 过程</h5><p>React Element在react执行它的reconciliation过程描述什么将被渲染，React Element可以分为两类：String或Function。String 类型的 React Element 代表原声 DOM 节点，Function 类型的 React Element 代表通过 React.Component 创建的组件<br>Function 类型的 React Element 将在 reconciliation 阶段被解析成 DOM 类型的 React Element （最终结果一定都是 DOM 元素）。<br>这点非常重要，这意味<strong>反向继承的高阶组件不保证一定解析整个子元素树</strong>。这对渲染劫持非常重要。</p>
<h5 id="可以用反向继承高阶组件做什么？"><a href="#可以用反向继承高阶组件做什么？" class="headerlink" title="可以用反向继承高阶组件做什么？"></a>可以用反向继承高阶组件做什么？</h5><ul>
<li>渲染劫持 Rendering Highjacking</li>
<li>操作state</li>
</ul>
<ol>
<li>渲染劫持<br>之所以被称为渲染劫持是因为高阶组件控制了WrappedComponent生成的渲染结果，并且可以各种操作。通过渲染劫持可以：<ul>
<li>读取，添加，删除，修改 任何一个将被渲染的React Element的 props</li>
<li>在渲染方法中读取或更改React Element tree，也就是 WrappedComponent 的 children</li>
<li>根据条件不同，选择性的渲染子树</li>
<li>给子树里的元素变更样式<br>其中渲染指的是 WrappedComponent.render 方法<blockquote>
<p>无法更改或创建 props 给 WrappedComponent 实例，因为 React 不允许变更一个组件收到的 props，但是你可以在 render 方法里更改子元素/子组件们的 props。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p>反向继承的高阶组件不保证一定渲染整个子元素树，这同时也给渲染劫持添加了一些限制。通过反向继承，只能劫持WrappedComponent渲染的元素，这意味着如果 WrappedComponent 的子元素里有 Function 类型的 React Element，你不能劫持这个元素里面的子元素树的渲染<br>例子:通过 render 来变成 React Elements tree 的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function iiHOC(WrappedComponent) &#123;</div><div class="line">  return class Enhancer extends WrappedComponent &#123;</div><div class="line">    render() &#123;</div><div class="line">      const elementsTree = super.render()</div><div class="line">      let newProps = &#123;&#125;;</div><div class="line">      if (elementsTree &amp;&amp; elementsTree.type === &apos;input&apos;) &#123;</div><div class="line">        newProps = &#123;value: &apos;may the force be with you&apos;&#125;</div><div class="line">      &#125;</div><div class="line">      const props = Object.assign(&#123;&#125;, elementsTree.props, newProps)</div><div class="line">      const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children)</div><div class="line">      return newElementsTree</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里你可以做任何操作，比如你可以遍历整个 element tree 然后变更某些元素的 props。这恰好就是 Radium 的工作方式。</p>
<blockquote>
<p>注意：你不能通过 Props Proxy 来做渲染劫持.<br>即使你可以通过 WrappedComponent.prototype.render 获取它的 render 方法，你需要自己手动模拟整个实例以及生命周期方法，而不是依靠 React，这是不值当的，应该使用反向继承来做到渲染劫持。要记住 React 在内部处理组件的实例，而你只通过 this 或 refs 来处理实例。</p>
</blockquote>
<ol>
<li>操作state<br>高阶组件可以<strong>读取，修改，删除</strong>WrappedComponent实例的state，必要的话可以添加新的state。但是注意的是，这样会弄乱WrappedComponent的state，导致破坏一些东西。通常不介意使用高阶组件来读取或添加state，添加state需要使用命名空间来防止与 WrappedComponent 的 state 冲突。<br>我们举个例子，通过显示 WrappedComponent 的 props 和 state 来 debug<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">export function IIHOCDEBUGGER(WrappedComponent) &#123;</div><div class="line">    return class II extends WrappedComponent &#123;</div><div class="line">        render() &#123;</div><div class="line">            return (</div><div class="line">                &lt;div&gt;</div><div class="line">                    &lt;h2&gt;HOC Debugger Component&lt;/h2&gt;</div><div class="line">                    &lt;p&gt;Props&lt;/p&gt; &lt;pre&gt;&#123;JSON.stringify(this.props, null, 2)&#125;&lt;/pre&gt;</div><div class="line">                    &lt;p&gt;State&lt;/p&gt;&lt;pre&gt;&#123;JSON.stringify(this.state, null, 2)&#125;&lt;/pre&gt;</div><div class="line">                    &#123;super.render()&#125;</div><div class="line">                &lt;/div&gt;</div><div class="line">            )</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>通过高阶组件包装一个组件时候，会丢失原先 WrappedComponent 的名字，可能会给开发和 debug 造成影响。常见的解决方法是在原先的 WrappedComponent 的名字前添加一个前缀，下面是从 React-Redux 中拿出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HOC.displayName = `HOC($getDisplayName(WrappedComponent))`</div><div class="line">或者</div><div class="line">class HOC extends WrappedComponent &#123;</div><div class="line">    static displayName = `HOC($getDisplayName(WrappedComponent))`</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中方法 getDisplayName 被如下定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function getDisplayName(WrappedComponent) &#123;</div><div class="line">    return WrappedComponent.displayName ||</div><div class="line">        WrappedComponent.name ||</div><div class="line">        `Component`</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，我们可以不需要自己写这个方法，因为 <a href="https://github.com/acdlite/recompose" target="_blank" rel="external">recompose</a>已经提供了。</p>
<h4 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h4><p>下面的案例是用了许多高阶组件思想，值得学习。</p>
<h5 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React-Redux"></a>React-Redux</h5><p>React-Redux 是 Redux 官方的对于 React 的绑定。 其中一个方法 connect 处理了所有关于监听 store 的 bootstrap 代码 以及清理工作，这是通过 Props Proxy 来实现的。<br>如果你曾经使用过 Flux 你会知道 React 组件需要和一个或多个 store 连接，并且添加/删除对 store 的监听，从中选择需要的那部分 state。而 React-Redux 帮你把它们实现了.</p>
<h5 id="Radium"><a href="#Radium" class="headerlink" title="Radium"></a>Radium</h5><p>Radium 是一个增强了行内（inline）css 能力的库，它允许在inline css 使用 css 伪选择器，<a href="https://speakerdeck.com/vjeux/react-css-in-js" target="_blank" rel="external">inline css</a>又被成为 CSS in JS。<br>Radium是怎么允许 inline css 来实现 CSS 伪选择器的呢，例如 hover？它实现了一个反向继承来使用渲染劫持，添加适当的事件监听来模拟 CSS 伪选择器，这要求 Radium 读取整个 WrappedComponent 将要渲染的元素树，每当找到元素带有的 style props，它就会添加对应的时间监听 props。简单地说，Radium 修改了原先元素树的props，实际上更加复杂。<br>Radium 只暴露了一个非常简单的API给开发者，而开发者几乎不会注意到它的存在和它是怎么发挥作用的，而实现了想要的功能。这揭露了高阶组件的能力。</p>
<h4 id="附录A-高阶组件和参数"><a href="#附录A-高阶组件和参数" class="headerlink" title="附录A: 高阶组件和参数"></a>附录A: 高阶组件和参数</h4><p>有时在高阶组件中使用参数很有用，举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function HOCFactoryFactory(...params) &#123;</div><div class="line">    // do something wiht params</div><div class="line">    return function HOCFactory(WrappedComponent) &#123;</div><div class="line">        return class HOC extends WrappedComponent &#123;</div><div class="line">            render() &#123;</div><div class="line">                return &lt;WrappedComponent &#123;...this.props&#125; /&gt;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以这样使用它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HOCFactoryFactory(params)(WrappedComponent)</div><div class="line">或者</div><div class="line">@HOCFactoryFactory(params)</div><div class="line">class WrappedComponent extends React.Component &#123;&#125;</div></pre></td></tr></table></figure></p>
<h4 id="附录B：和父组件的不同之处"><a href="#附录B：和父组件的不同之处" class="headerlink" title="附录B：和父组件的不同之处"></a>附录B：和父组件的不同之处</h4><p>父组件就是单纯的 React 组件包含了一些子组件（children）。React 提供了获取和操作一个组件的 children 的 APIs。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Parent extends React.Component &#123;</div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            &lt;div&gt;</div><div class="line">                &#123; this.props.children &#125;</div><div class="line">            &lt;/div&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">render((</div><div class="line">    &lt;Parent&gt;</div><div class="line">        &#123; children &#125;</div><div class="line">    &lt;/Parent&gt;</div><div class="line">), mountNode)</div></pre></td></tr></table></figure></p>
<h4 id="总结：高阶组件能做和不能做的"><a href="#总结：高阶组件能做和不能做的" class="headerlink" title="总结：高阶组件能做和不能做的"></a>总结：高阶组件能做和不能做的</h4><ul>
<li>渲染劫持</li>
<li>操作内部 props</li>
<li>抽象 state。但是有缺点，不能再父组件外获取到它的 state，除非明确地实现了钩子。</li>
<li>与新的 React Element 包装。这似乎是唯一一点，使用父组件要比高阶组件强，但高阶组件也同样可以实现。</li>
<li>Children 的操控。如果 children 不是单一 root，则需要多添加一层来包括所有 children，可能会使你的 markup 变得有点笨重。使用高阶组件可以保证单一 root。</li>
<li><p>父组件可以在元素树立随意使用，它们不像高阶组件一样限制于一个组件。<br>通常来讲，能使用父组件达到的效果，尽量不要用高阶组件，因为高阶组件是一种更 hack 的方法，但同时也有更高的灵活性。React 带来了很多创新，人们维护着像 Radium，React-Redux，React-Router 之类的项目，都是很好的证明。</p>
<h4 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h4></li>
</ul>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/22054582?refer=purerender" target="_blank" rel="external">基于Decorator的组件扩展实践</a></li>
<li><a href="http://www.jianshu.com/p/0aae7d4d9bc1" target="_blank" rel="external">深入理解 React 高阶组件</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/props/">props</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stateless/">stateless</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/高阶组件/">高阶组件</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-sass之四-mixin-include-placeholder-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/22/sass之四-mixin-include-placeholder-2/" class="article-date">
      <time datetime="2017-01-22T10:11:51.000Z" itemprop="datePublished">2017-01-22</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/22/sass之四-mixin-include-placeholder-2/">sass之四-mixin-include-placeholder(2)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/">%</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/extend/">extend</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/include/">include</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mixin/">mixin</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sass/">sass</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2017 罗旭
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>